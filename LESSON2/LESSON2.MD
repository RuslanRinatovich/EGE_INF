# Анализ задания 2 ЕГЭ по информатике

## Общая информация

- **Номер задания:** 2
- **Уровень сложности:** Базовый
- **Рекомендуемое время:** 3 минуты

## Проверяемые темы и умения

### Кодификатор ЕГЭ

**2.7. Алгебра логики**

- Понятие высказывания
- Высказывательные формы (предикаты)
- Кванторы существования и всеобщности
- Логические операции
- **Таблицы истинности**
- Логические выражения
- Логические тождества
- Логические операции и операции над множествами
- Законы алгебры логики
- Эквивалентные преобразования логических выражений
- Логические уравнения и системы уравнений
- Логические функции
- Зависимость количества возможных логических функций от количества аргументов
- Канонические формы логических выражений

**2.6. Умения**

- Строить логическое выражение в дизъюнктивной и конъюнктивной нормальных формах по заданной таблице истинности
- Исследовать область истинности высказывания, содержащего переменные
- Решать несложные логические уравнения

## Обозначения логических операций

| Операция                | Математическое обозначение | Альтернативное обозначение |
|-------------------------|----------------------------|----------------------------|
| НЕ (отрицание)          | ¬A                         | A̅                         |
| И (конъюнкция)          | A ∧ B                      | A · B                      |
| ИЛИ (дизъюнкция)        | A ∨ B                      | A + B                      |
| Импликация (следование) | A → B                      |                            |
| Эквивалентность         | A ≡ B                      |                            |

## Основные сведения

### Порядок выполнения операций

1. Операция «НЕ»
2. Операция «И»
3. Операция «ИЛИ»
4. Импликация
5. Эквивалентность

### Важные преобразования

**Выражение импликации:**

```
A → B = ¬A ∨ B
```

**Формулы де Моргана:**

```
¬(A ∧ B) = ¬A ∨ ¬B
¬(A ∨ B) = ¬A ∧ ¬B
```

### Свойства логических операций

**Логическая сумма (дизъюнкция):**

```
A + B + C + ... = 0 только когда ВСЕ слагаемые = 0
```

**Логическое произведение (конъюнкция):**

```
A · B · C · ... = 1 только когда ВСЕ сомножители = 1
```

**Импликация:**

```
A → B = 0 только когда A = 1 и B = 0
```

**Эквивалентность:**

```
A ≡ B = 1 только когда A и B равны (оба 0 или оба 1)
```

### Особенности таблиц истинности

- Таблица истинности определяет значения выражения при всех возможных комбинациях исходных данных
- При неполной таблице истинности невозможно однозначно определить логическое выражение
- Количество разных логических функций, удовлетворяющих неполной таблице истинности: `2^k`, где `k` - число
  отсутствующих строк

**Пример:**
Для выражения с тремя переменными (8 строк), если заданы только 6 строк:

```
Количество функций = 2^(8-6) = 2^2 = 4
```

## Стратегия решения

1. **Внимательно изучить обозначения** операций в конкретном задании
2. **Определить порядок выполнения операций** согласно приоритету
3. **Использовать эквивалентные преобразования** для упрощения выражений
4. **Проверять особые случаи** для импликации и эквивалентности
5. **Учитывать свойства** логических сумм и произведений

## Соответствие между математическими и Python операциями

### Таблица соответствия логических операций

| Математическая операция | Обозначение в логике | Операция в Python         | Пример       |
|-------------------------|----------------------|---------------------------|--------------|
| Отрицание (НЕ)          | ¬A                   | `not A`                   | `not x`      |
| Конъюнкция (И)          | A ∧ B                | `A and B`                 | `x and y`    |
| Дизъюнкция (ИЛИ)        | A ∨ B                | `A or B`                  | `x or y`     |
| Импликация (следование) | A → B                | `not A or B` или `A <= B` | `not x or y` |
| Эквивалентность         | A ≡ B                | `A == B`                  | `x == y`     |
| Исключающее ИЛИ (XOR)   | A ⊕ B                | `A != B`                  | `x != y`     |

# Пример 1.

# 23739 Демоверсия 2026 (Уровень: Базовый)(взят с сайта kompege.ru)

# Решение задания 2 ЕГЭ по информатике

## Условие задачи

Миша заполнял таблицу истинности логической функции:

**F = (x ∨ y) ∧ ¬(y ≡ z) ∧ ¬w**

Но успел заполнить лишь фрагмент из трёх различных её строк, даже не указав, какому столбцу таблицы соответствует каждая
из переменных **w, x, y, z**.

### Данный фрагмент таблицы:

| Столбец 1 | Столбец 2 | Столбец 3 | Столбец 4 | F |
|-----------|-----------|-----------|-----------|---|
| 1         |           | 1         |           | 1 |
| 0         | 1         |           | 0         | 1 |
|           | 1         | 1         | 0         | 1 |

**Задача:** Определить, какому столбцу таблицы соответствует каждая из переменных w, x, y, z.

**Формат ответа:** Буквы w, x, y, z в том порядке, в котором идут соответствующие им столбцы.

---

## Решение

Построим таблицу истинности с помощью python для данного выражения, а дальше проанализируем и сопоставим.

# Подробный разбор программы для построения таблицы истинности

## Исходный код программы

```python
print('x y z w')
for x in [0, 1]:
    for y in [0, 1]:
        for z in [0, 1]:
            for w in [0, 1]:
                f = (x or y) and not (y == z) and not w
                if f:
                    print(x, y, z, w)
```

## Пошаговое объяснение работы программы

### Шаг 1: Заголовок таблицы

```python
print('x y z w')
```

**Что делает:** Выводит заголовок таблицы с названиями переменных в порядке x, y, z, w.

**Результат:**

```
x y z w
```

### Шаг 2: Организация вложенных циклов

```python
for x in [0, 1]:
    for y in [0, 1]:
        for z in [0, 1]:
            for w in [0, 1]:
```

**Что делает:** Создает 4 вложенных цикла для перебора всех возможных комбинаций двоичных значений переменных x, y, z,
w.

**Количество итераций:** 2 × 2 × 2 × 2 = 16 (все возможные комбинации 4 переменных)

**Порядок перебора:**

```
x=0, y=0, z=0, w=0
x=0, y=0, z=0, w=1
x=0, y=0, z=1, w=0
x=0, y=0, z=1, w=1
x=0, y=1, z=0, w=0
...
x=1, y=1, z=1, w=1
```

### Шаг 3: Вычисление логического выражения

```python
f = (x or y) and not (y == z) and not w
```

**Разберем выражение по частям:**

1. **`(x or y)`** - логическое ИЛИ
    - Возвращает 1 (True), если хотя бы одна из переменных x или y равна 1
    - Возвращает 0 (False), только если обе переменные равны 0

2. **`(y == z)`** - эквивалентность (равенство)
    - Возвращает 1, если y и z равны (оба 0 или оба 1)
    - Возвращает 0, если y и z различны

3. **`not (y == z)`** - отрицание эквивалентности
    - Возвращает 1, когда y и z РАЗЛИЧНЫ (y ≠ z)
    - Возвращает 0, когда y и z равны

4. **`not w`** - отрицание w
    - Возвращает 1, когда w = 0
    - Возвращает 0, когда w = 1

5. **Полное выражение:** `(x or y) and not (y == z) and not w`
    - Используется логическое И (and) между всеми тремя частями
    - F = 1 только когда ВСЕ три условия выполняются одновременно

### Шаг 4: Проверка условия и вывод

```python
if f:
    print(x, y, z, w)
```

**Что делает:**

- Проверяет, равно ли значение f истине (1/True)
- Если да, выводит текущие значения переменных x, y, z, w
- Если нет, переходит к следующей комбинации

## Детальный процесс выполнения

### Для лучшего понимания рассмотрим несколько итераций:

**Итерация 1:** x=0, y=0, z=0, w=0

```
(x or y) = (0 or 0) = 0
(y == z) = (0 == 0) = 1
not (y == z) = not 1 = 0
not w = not 0 = 1
f = 0 and 0 and 1 = 0 ❌ (не выводим)
```

**Итерация 5:** x=0, y=1, z=0, w=0

```
(x or y) = (0 or 1) = 1
(y == z) = (1 == 0) = 0
not (y == z) = not 0 = 1
not w = not 0 = 1
f = 1 and 1 and 1 = 1 ✅ (ВЫВОДИМ: 0 1 0 0)
```

**Итерация 11:** x=1, y=0, z=1, w=0

```
(x or y) = (1 or 0) = 1
(y == z) = (0 == 1) = 0
not (y == z) = not 0 = 1
not w = not 0 = 1
f = 1 and 1 and 1 = 1 ✅ (ВЫВОДИМ: 1 0 1 0)
```

**Итерация 13:** x=1, y=1, z=0, w=0

```
(x or y) = (1 or 1) = 1
(y == z) = (1 == 0) = 0
not (y == z) = not 0 = 1
not w = not 0 = 1
f = 1 and 1 and 1 = 1 ✅ (ВЫВОДИМ: 1 1 0 0)
```

## Итоговый вывод программы

```
x y z w
0 1 0 0
1 0 1 0
1 1 0 0
```

## Что дает этот результат для решения задачи?

Программа находит ВСЕ комбинации переменных, при которых исходная логическая функция F принимает значение 1. Всего таких
комбинаций оказалось 3:

1. **x=0, y=1, z=0, w=0**
2. **x=1, y=0, z=1, w=0**
3. **x=1, y=1, z=0, w=0**

**Ключевые наблюдения:**

- Во всех случаях **w = 0** (это важно для определения столбца w)
- Переменные x, y, z принимают различные значения в разных строках
- Это позволяет сопоставить фрагмент таблицы из условия с полной таблицей истинности

Данная программа автоматически выполняет трудоемкую работу по перебору всех вариантов и вычислению значений функции, что
значительно ускоряет решение задачи.

---

Проанализируем полученную таблицу и матрицу из задания.

### Фрагмент таблицы из задания:

| Столбец 1 | Столбец 2 | Столбец 3 | Столбец 4 | F |
|-----------|-----------|-----------|-----------|---|
| 1         |           | 1         |           | 1 |
| 0         | 1         |           | 0         | 1 |
|           | 1         | 1         | 0         | 1 |

## Итоговый вывод программы

```
x y z w
0 1 0 0
1 0 1 0
1 1 0 0
```

1. Заметим что w всегда принимает значение 0.
2. Единственный столбец, в котором могут быть все нули будет солбец под №4. Следовательно это **w**

| Столбец 1 | Столбец 2 | Столбец 3 | **w** | F |
|-----------|-----------|-----------|-------|---|
| 1         |           | 1         | **0** | 1 |
| 0         | 1         |           | 0     | 1 |
|           | 1         | 1         | 0     | 1 |

3. z - принимает следующие значения 0 1 0. Это единственная переменная из оставшихся, которая отличается от x и y.
4. Если проанализировать первый столбец исходной матрицы, то можно также заметить, что это единственный столбей из
   оставшихся трех, в котором можно поставить два нуля и единицу. Следовательно первый столбец это переменная **z**.

| **z** | Столбец 2 | Столбец 3 | **w** | F |
|-------|-----------|-----------|-------|---|
| 1     |           | 1         | **0** | 1 |
| 0     | 1         |           | 0     | 1 |
| **0** | 1         | 1         | 0     | 1 |

5. Осталось распределить переменные x и y. Для начала дозаполним оставшиеся ячейки нулями, поскольку исходя из
   построенной таблицы истинности в оставшихся столбца будет по одному нулю.

| **z** | Столбец 2 | Столбец 3 | **w** | F |
|-------|-----------|-----------|-------|---|
| 1     | **0**     | 1         | **0** | 1 |
| 0     | 1         | **0**     | 0     | 1 |
| **0** | 1         | 1         | 0     | 1 |

6. Теперь посмотрим на таблицу истинности и посмотрим на строку в которой z = 1. Обратим внимание на поведение
   переменных x и y.
   Заметим, что при z = 1, x = 1, a y = 0.

```
x y z w
1 0 1 0
```

7. Следовательно, сопоставив наши наблюдения с исходной матрицей получим, что y это столбец под номером 2, а x
   соответствует столбец 3.

| **z** | **y** | **x** | w     | F |
|-------|-------|-------|-------|---|
| **1** | **0** | **1** | **0** | 1 |
| 0     | 1     | 0     | 0     | 1 |
| 0     | 1     | 1     | 0     | 1 |

ОТВЕТ: **zyxw**

# Пример 2

# 21697 ЕГКР 19.04.25 (Уровень: Базовый) (Уровень: Базовый)(взят с сайта kompege.ru)

# Решение задания 2 ЕГЭ по информатике

## Условие задачи

Миша заполнял таблицу истинности логической функции:

**F = ¬(x -> y) ∨ (z ≡ w) ∨ z**

Но успел заполнить лишь фрагмент из трёх различных её строк, даже не указав, какому столбцу таблицы соответствует каждая
из переменных **w, x, y, z**.

### Данный фрагмент таблицы:

| Столбец 1 | Столбец 2 | Столбец 3 | Столбец 4 | F |
|-----------|-----------|-----------|-----------|---|
| 0         | 0         |           |           | 0 |
|           |           | 1         |           | 0 |
|           | 1         | 0         |           | 0 |

**Задача:** Определить, какому столбцу таблицы соответствует каждая из переменных
w, x, y, z.

## Исходный код программы

### вариант 1

```python
print('x y z w')
for x in [0, 1]:
    for y in [0, 1]:
        for z in [0, 1]:
            for w in [0, 1]:
                f = not (x <= y) or (z == w) or z
                if not f:
                    print(x, y, z, w)
```

###       

можно заменить четыре вложенных цикла на более лаконичную запись,

### вариант 2

```python
from itertools import product

print('x y z w')
for x, y, z, w in product([0, 1], repeat=4):
    f = not (x <= y) or (z == w) or z
    if not f:
        print(x, y, z, w)
```


---
ИТОГОВОЕ РЕШЕНИЕ

Проанализируем полученную таблицу и матрицу из задания.

### Фрагмент таблицы из задания:

| Столбец 1 | Столбец 2 | Столбец 3 | Столбец 4 | F |
|-----------|-----------|-----------|-----------|---|
| 0         | 0         |           |           | 0 |
|           |           | 1         |           | 0 |
|           | 1         | 0         |           | 0 |

## Итоговый вывод программы

```
x y z w
0 0 0 1
0 1 0 1
1 1 0 1
```

1. Заметим что w всегда принимает значение 1.
2. Единственный столбец, в котором могут быть все единицы будет столбец под №4. Следовательно это **w**
3. Также заметим, что z всегда принимает значения 0. Столбец куда можно поставить все нули это столбец под номером 1.

| **z** | Столбец 2 | Столбец 3 | **w** | F |
|-------|-----------|-----------|-------|---|
| **0** | 0         |           | **1** | 0 |
| **0** |           | 1         | **1** | 0 |
| **0** | 1         | 0         | **1** | 0 |

4. Обратим внимание, что в первой строке таблицы истинности, которую вывела программа три ноля, а в третьей строке три
   единицы. Значит дополним матрицу недостающими нулями и единицами. В первую строку добавим ноль во третий столбец, а в
   третью строку во второй столбец добавим 1.

| **z** | Столбец 2 | Столбец 3 | **w** | F |
|-------|-----------|-----------|-------|---|
| 0     | 0         | **0**     | 1     | 0 |
| 0     | **1**     | 1         | 1     | 0 |
| 0     | 1         | 0         | 1     | 0 |

5. Теперь получаем, что столбец 2 это переменная y(так как она принимает 0 и две единицы), а столбец 3 переменная х.

| **z** | **y** | **x** | **w** | F |
|-------|-------|-------|-------|---|
| 0     | 0     | 0     | 1     | 0 |
| 0     | 1     | 1     | 1     | 0 |
| 0     | 1     | 0     | 1     | 0 |

ОТВЕТ: **zyxw**

# Подробный разбор программы с использованием `itertools.product`

## Исходный код программы

```python
from itertools import product

print('x y z w')
for x, y, z, w in product([0, 1], repeat=4):
    f = not (x <= y) or (z == w) or z
    if not f:
        print(x, y, z, w)
```

## Что такое `itertools.product`?

### Основное понятие

`itertools.product()` - это функция из стандартной библиотеки Python, которая вычисляет **декартово произведение**
входных итерируемых объектов.

**Декартово произведение** - это множество всех возможных упорядоченных пар (или кортежей) элементов из заданных
множеств.

### Синтаксис

```python
product(iterable1, iterable2, ..., repeat=1)
```

### Примеры работы

**Пример 1:** Простое произведение

```python
from itertools import product

for a, b in product([0, 1], [0, 1]):
    print(a, b)
```

**Вывод:**

```
0 0
0 1
1 0
1 1
```

**Пример 2:** С параметром `repeat`

```python
from itertools import product

for a, b in product([0, 1], repeat=2):
    print(a, b)
```

**Вывод:**

```
0 0
0 1
1 0
1 1
```

## Подробное объяснение нашей программы

### Шаг 1: Импорт модуля

```python
from itertools import product
```

**Что делает:** Импортирует функцию `product` из модуля `itertools` для использования в программе.

### Шаг 2: Вывод заголовка

```python
print('x y z w')
```

**Что делает:** Выводит заголовок таблицы с названиями переменных.

### Шаг 3: Основной цикл с product

```python
for x, y, z, w in product([0, 1], repeat=4):
```

**Что происходит:**

- `product([0, 1], repeat=4)` создает декартово произведение множества `[0, 1]` само на себя 4 раза
- Это эквивалентно: `[0, 1] × [0, 1] × [0, 1] × [0, 1]`
- Генерируются все возможные кортежи длины 4 из элементов 0 и 1

**Количество элементов:** 2⁴ = 16 комбинаций

**Порядок генерации:**

```python
(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 1, 0, 0)
(0, 1, 0, 1)
(0, 1, 1, 0)
(0, 1, 1, 1)
(1, 0, 0, 0)
(1, 0, 0, 1)
(1, 0, 1, 0)
(1, 0, 1, 1)
(1, 1, 0, 0)
(1, 1, 0, 1)
(1, 1, 1, 0)
(1, 1, 1, 1)
```

### Шаг 4: Автоматическое распаковка кортежа

```python
for x, y, z, w in product([0, 1], repeat=4):
```

**Что делает:** Каждый сгенерированный кортеж автоматически распаковывается в переменные x, y, z, w.

**Пример:**

- Кортеж `(0, 1, 0, 1)` распаковывается как:
    - `x = 0`
    - `y = 1`
    - `z = 0`
    - `w = 1`

### Шаг 5: Вычисление логического выражения

```python
f = not (x <= y) or (z == w) or z
```

**Разберем выражение с учетом замен операций:**

1. **`(x <= y)`** - импликация в Python
    - В математической логике: x → y
    - В Python можно записать как `x <= y` или `not x or y`
    - Возвращает 0 только когда x=1 и y=0

2. **`not (x <= y)`** - отрицание импликации
    - Эквивалентно x=1 и y=0

3. **`(z == w)`** - эквивалентность
    - Возвращает 1 когда z и w равны

4. **Полное выражение:** `not (x <= y) or (z == w) or z`
    - Логическое ИЛИ между тремя частями

### Шаг 6: Проверка и вывод

```python
if not f:
    print(x, y, z, w)
```

**Что делает:** Выводит только те комбинации, где функция f принимает значение 0 (False).

## Сравнение двух версий программ

### Версия 1: Вложенные циклы

```python
for x in [0, 1]:
    for y in [0, 1]:
        for z in [0, 1]:
            for w in [0, 1]:
```

**Преимущества:**

- Более понятна начинающим
- Явно показывает структуру перебора

**Недостатки:**

- Многострочный код
- Сложно масштабировать для большего числа переменных

### Версия 2: С `itertools.product`

```python
for x, y, z, w in product([0, 1], repeat=4):
```

**Преимущества:**

- Компактная запись
- Легко масштабируется (достаточно изменить `repeat`)
- Более "питонический" стиль

**Недостатки:**

- Требует знания дополнительных модулей
- Менее очевидна для новичков

## Практическое применение для задач ЕГЭ

### Для построения таблиц истинности с разным количеством переменных:

**3 переменные:**

```python
for x, y, z in product([0, 1], repeat=3):
```

**5 переменных:**

```python
for x, y, z, w, v in product([0, 1], repeat=5):
```

### Пример для другой логической функции

```python
from itertools import product

print('x y z')
for x, y, z in product([0, 1], repeat=3):
    f = (x and not y) or (y == z)
    if f:
        print(x, y, z)
```

## Вывод

Обе программы решают одну и ту же задачу, но версия с `itertools.product` более элегантна и масштабируема. Для задач
ЕГЭ, где обычно требуется перебрать 3-4 переменные, оба подхода эффективны, но знание `product` может сэкономить время и
сделать код чище.

