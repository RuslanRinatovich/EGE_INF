# Задание 5 ЕГЭ по информатике  
## Анализ, теория и разборы типовых задач

---

## Оглавление

- [Анализ задания 5 ЕГЭ по информатике](#анализ-задания-5-егэ-по-информатике)
- [Теория для задания №5: Алгоритмы обработки чисел в системах счисления](#теория-для-задания-№5-алгоритмы-обработки-чисел-в-системах-счисления)
- [Типичные схемы задач](#типичные-схемы-задач)
- [Стратегия решения](#стратегия-решения)
- [Задача 5 (общий разбор)](#задача-5-общий-разбор)
- [Примеры и разборы](#примеры-и-разборы)
  - [Разбор 1. Пример №23742 — Двоичная система, минимальное N, R ≥ 200](#-разбор-1-kompege-23742)
  - [Разбор 2. Пример №23364 — Троичная система, максимальное N, R < 100](#-разбор-2-kompege-23364)
  - [Разбор 3. Пример №22272 — Девятеричная система, максимальное N при наибольшем R < 2876](#-разбор-3-kompege-22272)
  - [Разбор 4. Пример №19871 — Пятеричная система, минимальное N, ровно 4 нуля в R](#-разбор-4-kompege-19871)

---

## Анализ задания 5 ЕГЭ по информатике

- **Номер задания:** 5  
- **Уровень сложности:** Базовый  
- **Рекомендуемое время:** 4–6 минут  
- **Тип ответа:** Целое число (значение исходного числа `N` в десятичной системе счисления)

### Проверяемые умения (по кодификатору)

- **1.1. Системы счисления**  
- **2.9. Анализ алгоритмов**  
- **3.3. Формальное исполнение алгоритма**

### Что проверяется

- Умение формально исполнять алгоритм, описанный на естественном языке
- Умение моделировать работу алгоритма с числами в различных системах счисления
- Умение находить исходные данные (`N`), при которых результат (`R`) удовлетворяет заданному условию

### Особенности задания

- Алгоритм всегда описан **пошагово на естественном языке**
- Правило обработки зависит от **свойств числа `N`** (чётность, делимость и т.п.), а не от его записи
- Результат `R` — это **число**, а не строка; ведущие нули **автоматически игнорируются**
- В ответе всегда требуется указать **исходное число `N` в десятичной системе**

---

## Теория для задания №5: Алгоритмы обработки чисел в системах счисления

### Основные понятия

- **Система счисления с основанием `q`**: запись числа с использованием цифр от `0` до `q−1`.
- **Строковое представление числа**: удобно для операций типа «дописать», «заменить», «поменять местами».
- **Незначащие (ведущие) нули**: не влияют на значение числа и **всегда отбрасываются** при интерпретации строки как числа.

### Важные факты

- При добавлении нуля справа к двоичной записи число **удваивается**.
- Чтобы отбросить последнюю цифру в двоичной записи — **делить на 2 нацело**.
- Сумма двух десятичных цифр — от **0 до 18**.
- Бит чётности — дополнительный бит, чтобы общее число единиц стало **чётным**.

### Работа с системами счисления в Python

| Операция | Пример |
|--------|--------|
| Перевод в двоичную | `f'{n:b}'` или `bin(n)[2:]` |
| Перевод в произвольную систему | см. функцию `to_base()` ниже |
| Интерпретация строки как числа | `int(s, base)` |
| Удаление ведущих нулей | `int(s, base)` → `to_base(...)` |

---

## Типичные схемы задач

Все задачи задания 5 следуют одной структуре:

1. **Вход**: натуральное число `N`.
2. **Шаг 1**: построить запись `N` в системе счисления с основанием `q` (2, 3, 5, 9 и др.).
3. **Шаг 2**: применить правило, зависящее от свойств `N`:
   - чётность (`N % 2 == 0`)
   - делимость (`N % k == 0`)
   - значение остатка (`N % k`)
4. **Шаг 3**: полученная строка — запись числа `R` в той же системе.
5. **Требуется**: найти **минимальное** или **максимальное** `N`, при котором `R` удовлетворяет условию:
   - `R ≥ X` или `R < X`
   - содержит ровно `K` нулей/единиц
   - имеет определённую длину
   - является чётным/нечётным и т.п.

---

## Стратегия решения

### 1. Реализуйте перевод в нужную систему счисления

```python
def to_base(n, base):
    if n == 0:
        return '0'
    s = ''
    while n:
        s = str(n % base) + s
        n //= base
    return s
```

> Для двоичной системы можно использовать `f'{n:b}'`.

### 2. Смоделируйте алгоритм

- Работайте со строкой записи числа.
- Используйте срезы (`x[-3:]`, `x[1:-1]`), конкатенацию (`+`), замену (`replace`).
- Для замены двух символов одновременно (например, 3 ↔ 6) используйте **временный символ**.

### 3. Нормализуйте результат

```python
r_str = to_base(int(modified_str, base), base)
```

Это удаляет ведущие нули и даёт корректную запись `R`.

### 4. Организуйте перебор

- **Минимальное `N`** → `for n in range(1, limit):`
- **Максимальное `N`** → `for n in range(limit, 0, -1):`
- Если нужно **наибольшее R при R < X**, сохраняйте все подходящие пары `(N, R)` и сортируйте.

### 5. Проверяйте условие и выводите ответ

- Используйте `break` при поиске первого (мин/макс) значения.
- При поиске **наилучшего R** — собирайте список и сортируйте:  
  `a.sort(key=lambda p: (p[1], p[0]), reverse=True)`

---

---

## Задача 5 (общий разбор)

> *Этот раздел содержит обобщённый подход к типовым задачам задания 5 ЕГЭ.*

### Типовая формулировка

Дано натуральное число `N`. Алгоритм строит новое число `R` следующим образом:

1. Переводит `N` в систему счисления с основанием `q`.
2. Применяет правило, зависящее от свойств `N` (чётность, делимость, длина записи и т.д.).
3. Полученную строку интерпретирует как число в той же системе счисления → это `R`.

Требуется найти минимальное (или максимальное) `N`, при котором `R` удовлетворяет заданному условию.

---

### Универсальный шаблон решения на Python

```python
def to_base(n, base):
    if n == 0:
        return '0'
    s = ''
    while n:
        s = str(n % base) + s
        n //= base
    return s


for n in range(1, 100000):  # подобрать верхнюю границу
    rep = to_base(n, q)     # q — основание системы (2, 3, 5 и т.д.)

    if условие_на_N:
        # модификация rep по правилу 1
        pass
    else:
        # модификация rep по правилу 2
        pass

    # Удаление ведущих нулей через преобразование
    r = to_base(int(rep, q), q)

    if выполняется_условие_на_R:
        print(n)
        break
```

---

### Пояснение ключевых шагов

- **`to_base(n, q)`** — функция перевода в произвольную систему счисления.
- **`int(rep, q)`** — интерпретация строки `rep` как числа в системе с основанием `q`. Автоматически убирает ведущие нули.
- **Модификация строки** — почти всегда работает с `rep` как со строкой: индексы, срезы, конкатенация.
- **Проверка условия** — чаще всего подсчёт символов (`count('0')`, `count('1')`), проверка длины, чётности и т.п.

---

### Советы для учеников

1. Всегда проверяйте поведение алгоритма на малых значениях `N` вручную.
2. Не забывайте: после модификации строка может начинаться с нуля — но `int(..., base)` это корректно обработает.
3. Используйте `range(1, 10000)` или больше — в большинстве задач ответ укладывается в этот диапазон.
4. Если в задаче упоминается "незначащие нули", это сигнал: нужно выполнить `int(...) → to_base(...)` для нормализации.

--- 


## Примеры и разборы

---

### 📘 Разбор 1. Пример №23742

**Условие**  
Алгоритм:
1. Строится двоичная запись `N`.
2. Если `N` делится на 3 — дописываются **три последние цифры**.
3. Иначе — дописывается двоичная запись `(N % 3) × 3`.  
Найдите **минимальное** `N`, при котором `R ≥ 200`.

**Решение с подробными комментариями**

```python
# Перебираем N от 1 до 200 (достаточно для нахождения ответа)
for n in range(1, 200):
    # Шаг 1: получаем двоичную запись числа N как строку (без '0b')
    x = f'{n:b}'  # Например: n=12 → x='1100'

    # Шаг 2: применяем правило в зависимости от делимости на 3
    if n % 3 == 0:
        # Если N делится на 3 — берём три последние цифры
        # x[-3:] означает "последние 3 символа"; если их меньше — берутся все
        x = x + x[-3:]  # Пример: '1100' → '1100' + '100' = '1100100'
    else:
        # Если не делится — вычисляем остаток, умножаем на 3
        remainder = n % 3        # Может быть 1 или 2
        value_to_append = remainder * 3  # Получаем 3 или 6
        # Переводим это значение в двоичную запись и дописываем
        x = x + f'{value_to_append:b}'  # 3 → '11', 6 → '110'

    # Шаг 3: интерпретируем полученную строку как двоичное число → R в десятичной
    r = int(x, 2)  # Например: int('1100100', 2) = 100

    # Шаг 4: проверяем условие задачи
    if r >= 200:
        print(n)   # Выводим первое (минимальное) подходящее N
        break      # Прерываем цикл — дальше искать не нужно
```

**Ключевые моменты**
- `f'{n:b}'` — удобный способ получить двоичную запись без префикса.
- `x[-3:]` корректно работает даже если длина строки < 3.
- `int(x, 2)` автоматически игнорирует ведущие нули и даёт правильное значение `R`.

**Ответ**: `26`

---

### 📘 Разбор 2. Пример №23364

**Условие**  
Алгоритм:
1. Строится троичная запись `N`.
2. Если `N % 3 == 0` → слева `'1'`, справа `'02'`.
3. Иначе → справа дописывается троичная запись `(N % 3) × 4`.  
Найдите **максимальное** `N`, при котором `R < 100`.

**Решение с подробными комментариями**

```python
# Вспомогательная функция: перевод числа в троичную систему
def convert_to_3(number):
    # Обработка особого случая: 0 → '0'
    if number == 0:
        return '0'
    s = ''
    # Пока число не стало нулём
    while number:
        # Берём остаток от деления на 3 — это очередная цифра
        digit = number % 3
        # Добавляем её в начало строки (т.к. цифры получаем справа налево)
        s = str(digit) + s
        # Делим число на 3 нацело
        number //= 3
    return s


# Перебираем N от 200 до 1 в обратном порядке — ищем МАКСИМАЛЬНОЕ
for n in range(200, 0, -1):
    # Шаг 1: получаем троичную запись числа N
    x = convert_to_3(n)  # Например: n=8 → '22'

    # Шаг 2: применяем правило
    if n % 3 == 0:
        # Если делится на 3 — приписываем '1' слева и '02' справа
        x = '1' + x + '02'  # Пример: '100' → '110002'
    else:
        # Если не делится — вычисляем (остаток * 4) и переводим в троичную
        remainder = n % 3        # 1 или 2
        value_to_append = remainder * 4  # 4 или 8
        # Дописываем троичную запись этого значения
        x = x + convert_to_3(value_to_append)  # 4 → '11', 8 → '22'

    # Шаг 3: интерпретируем строку как троичное число → R в десятичной
    r = int(x, 3)

    # Шаг 4: проверяем условие
    if r < 100:
        print(n)   # Первое найденное — максимальное (т.к. перебор с конца)
        break
```

**Ключевые моменты**
- Перебор **в обратном порядке** позволяет сразу найти **максимальное** `N`.
- Функция `convert_to_3` реализует стандартный алгоритм перевода через деление.
- `int(x, 3)` корректно обрабатывает любую корректную троичную строку.

**Ответ**: `10`

---

### 📘 Разбор 3. Пример №22272

**Условие**  
Алгоритм:
1. Строится девятеричная запись `N`.
2. Если начинается на `'7'`:
   - заменить `6 ↔ 3`,
   - слева приписать `'34'`.
3. Иначе:
   - первую цифру заменить на `'3'`,
   - справа приписать `'45'`.  
Найдите **максимальное** `N`, при котором `R` — **наибольшее возможное**, но **меньше 2876**.

**Решение с подробными комментариями**

```python
# Функция перевода в девятеричную систему
def convert_to_9(number):
    if number == 0:
        return '0'
    s = ''
    while number:
        s = str(number % 9) + s
        number //= 9
    return s


# Список для хранения всех подходящих пар (N, R)
valid_pairs = []

# Перебираем N от 1000 до 1 (в обратном порядке — для полноты)
for n in range(1000, 0, -1):
    # Шаг 1: получаем девятеричную запись
    x = convert_to_9(n)

    # Шаг 2: применяем правило в зависимости от первой цифры
    if x[0] == '7':
        # Замена 6 на 3 и 3 на 6 одновременно
        # Используем временный символ '*', чтобы избежать конфликта
        x = x.replace('6', '*')   # сначала 6 → *
        x = x.replace('3', '6')   # потом 3 → 6
        x = x.replace('*', '3')   # наконец * → 3
        # Приписываем '34' слева
        x = '34' + x
    else:
        # Заменяем первую цифру на '3' и приписываем '45' справа
        # x[1:] — все символы, кроме первого
        x = '3' + x[1:] + '45'

    # Шаг 3: получаем R в десятичной системе
    r = int(x, 9)

    # Шаг 4: сохраняем только те пары, где R < 2876
    if r < 2876:
        valid_pairs.append((n, r))

# Сортируем пары:
# - сначала по R (по убыванию — хотим наибольшее R),
# - затем по N (по убыванию — при равных R берём наибольшее N)
valid_pairs.sort(key=lambda pair: (pair[1], pair[0]), reverse=True)

# Первая пара в отсортированном списке — искомая
print(valid_pairs[0][0])
```

**Ключевые моменты**
- Замена двух символов **одновременно** требует промежуточного символа.
- Условие требует **наибольшее R**, а не наибольшее N → нужна сортировка.
- `x[0]` безопасно, так как `N ≥ 1` → запись не пуста.

**Ответ**: `79`

---

### 📘 Разбор 4. Пример №19871

**Условие**  
Алгоритм:
1. Строится пятеричная запись `N`.
2. Если `N` чётное — справа дописывается пятеричная запись `(младший разряд × 3)`.
3. Если нечётное — поменять первую и последнюю цифры, затем дописать `'1'`.  
Найдите **минимальное** `N`, при котором в `R` ровно **4 значащих нуля**.

**Решение с подробными комментариями**

```python
# Функция перевода в пятеричную систему
def convert_to_5(number):
    if number == 0:
        return '0'
    s = ''
    while number:
        s = str(number % 5) + s
        number //= 5
    return s


# Перебираем N от 1 до 10000 (достаточно для нахождения ответа)
for n in range(1, 10000):
    # Шаг 1: получаем пятеричную запись числа N
    x = convert_to_5(n)

    # Шаг 2: применяем правило в зависимости от чётности
    if n % 2 == 0:
        # Чётное: берём младший разряд (последний символ)
        last_digit_char = x[-1]          # Например: '2000' → '0'
        last_digit_int = int(last_digit_char)  # Преобразуем в число
        # Умножаем на 3 и переводим результат в пятеричную запись
        appended_part = convert_to_5(last_digit_int * 3)
        # Дописываем к исходной записи
        x = x + appended_part
    else:
        # Нечётное: меняем местами первую и последнюю цифры
        if len(x) > 1:
            # x[-1] — последняя, x[1:-1] — середина, x[0] — первая
            x = x[-1] + x[1:-1] + x[0]
        # В любом случае (даже при одной цифре) дописываем '1' справа
        x = x + '1'

    # Шаг 3: нормализуем результат — удаляем ведущие нули
    # int(x, 5) интерпретирует строку как пятеричное число
    # convert_to_5(...) даёт каноническую запись без ведущих нулей
    r_normalized = convert_to_5(int(x, 5))

    # Шаг 4: считаем количество нулей в нормализованной записи
    # Так как ведущих нулей нет, все нули — значащие
    if r_normalized.count('0') == 4:
        print(n)
        break
```

**Ключевые моменты**
- `x[-1]` всегда существует, так как `N ≥ 1`.
- Обмен первой и последней цифр выполняется **только если длина > 1**.
- Двойное преобразование `int(...) → convert_to_5(...)` гарантирует отсутствие ведущих нулей.
- `count('0')` считает **все нули**, но в нормализованной записи они все значащие.

**Ответ**: `250`

---

> 💡 **Совет ученикам**:  
> Всегда проверяйте 1–2 примера из условия вручную.  
> Используйте `print()` для отладки промежуточных значений.  
> Не забывайте про **граничные случаи**: однозначные числа, нулевые разряды, пустые срезы.
